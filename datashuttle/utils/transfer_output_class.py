from __future__ import annotations

from collections import UserDict


class TransferOutput(UserDict):
    """Class to hold important information about a Rclone Transfer."""

    def __init__(self) -> None:
        """Construct a dictionary to hold the key output after RClone data transfers.

        This dictionary holds information on the number of transferred files
        and any errors which occurred during `rclone copy` transfer.

        The dict entries are:

        errors:
            file_names
                A list of file names associated with errors.

            messages
                A list of messages associated with errors. For each file name,
                there will be an associated message, but it is also possible to
                have messages that are not associated with any file name.

        num_transferred:
            rawdata or derivatives
                A flag that can take the value `None` or an int.
                If `None`, this top-level folder was not attempted to be transferred.
                If an int, it is the number of files transferred. If 0, this means
                a transfer was attempted, but no files were transferred.
                For example, `upload_entire_project()` will attempt to upload
                rawdata and derivatives, even if derivatives does not exist.
                `upload_rawdata` will only attempt to upload rawdata.
        """
        super().__init__(
            {
                "errors": {"file_names": [], "messages": []},
                "num_transferred": {
                    "rawdata": None,
                    "derivatives": None,
                },
            }
        )

    def errors_detected(self) -> bool:
        """Return whether any errors occurred during transfer."""
        return any(self["errors"]["messages"])

    @classmethod
    def merge_std_outputs(
        cls, stdout_outputs: TransferOutput, stderr_outputs: TransferOutput
    ):
        """Instantiate the dictionary from stdout and stderr captures from RClone output.

        This merges stdout and stderr outputs of RClones transfers,
        generated by the function `reformat_rclone_copy_output`.
        """
        # Note `stdout_outputs` 'num_transferred' entries are not expected to be filled in.
        # This is not ideal, but beats having to two dict formats just to handle this case.
        # The std err entry is expected to be filled in, otherwise the RClone log format is not as we expect
        for key in ["rawdata", "derivatives"]:
            assert stdout_outputs["num_transferred"][key] is None

        instance = cls()

        instance["errors"]["file_names"] = list(
            set(
                stdout_outputs["errors"]["file_names"]
                + stderr_outputs["errors"]["file_names"]
            )
        )

        instance["errors"]["messages"] = (
            stdout_outputs["errors"]["messages"]
            + stderr_outputs["errors"]["messages"]
        )

        instance["num_transferred"]["rawdata"] = stderr_outputs[
            "num_transferred"
        ]["rawdata"]
        instance["num_transferred"]["derivatives"] = stderr_outputs[
            "num_transferred"
        ]["derivatives"]

        return instance

    def create_tui_message(self, no_transfer_color, transfer_color) -> str:
        """Create a message summarising the transfer, for display in the TUI.

        This is very similar to `self.create_python_api_message()`, but these
        are sufficient subtle differences to warrant two separate functions.
        """
        message = ""

        for top_level_folder in ["rawdata", "derivatives"]:
            num_transferred = self["num_transferred"][top_level_folder]

            if num_transferred is None:
                continue

            elif num_transferred == 0:
                message += (
                    f"[{no_transfer_color}]"
                    f"\nNothing was transferred from {top_level_folder}."
                    f"[/{no_transfer_color}]\n"
                )

            else:
                files_were = (
                    "files were" if num_transferred > 1 else "file was"
                )
                message += (
                    f"[{transfer_color}]"
                    f"\n{num_transferred} {files_were} transferred from {top_level_folder}."
                    f"[/{transfer_color}]\n"
                )

        errors_dict = self["errors"]

        if any(errors_dict["messages"]):
            if errors_dict["file_names"]:
                message += "\n[red]Errors detected! in files:[/red]\n"
                message += "\n".join(errors_dict["file_names"])
            else:
                message += "\n[red]Errors detected![/red]"
            message += "[red]\n\nThe error messages are:[/red]\n"
            message += "\n\n".join(errors_dict["messages"])

        return message

    def create_python_api_message(self):
        """Create a message summarising the transfer, for display in the TUI."""
        message = ""

        for top_level_folder in ["rawdata", "derivatives"]:
            num_transferred = self["num_transferred"][top_level_folder]

            if num_transferred is None:
                continue

            elif num_transferred == 0:
                message += (
                    f"\nNothing was transferred from {top_level_folder}.\n"
                )

            else:
                files_were = (
                    "files were" if num_transferred > 1 else "file was"
                )
                message += f"\n{num_transferred} {files_were} transferred from {top_level_folder}.\n"

        errors = self["errors"]

        if any(errors["messages"]):
            if any(errors["file_names"]):
                message += (
                    "\n\nErrors were detected! In files:"
                    "\n-------------------------------\n"
                )
                message += "\n".join(errors["file_names"])
            else:
                message += "\n\n[red]Errors detected![/red]"
            message += "\n\nThe error messages are:\n-----------------------\n"
            message += "\n".join(errors["messages"])
            message += "\n"

        return message
